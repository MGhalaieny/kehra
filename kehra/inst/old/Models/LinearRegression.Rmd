---
title: "Linear Regression"
author: "Claudia Vitolo"
date: "9 November 2015"
output: html_document
---

```{r setup, include=FALSE}
# Enable caching of results globally
knitr::opts_chunk$set(cache=TRUE)
```

# Linear regression
Collect information on PM10 and Temperature.

```{r}
# Clean the current environment
rm(list = ls())

# Load the dataset, choose between:
# A. original dataset
df <- readRDS("~/Dropbox/Projects/kehra/data/Pollution/allPollutantsClima.rds")
# B. dataset after cleanup (remember there are transformed variables!)
# df <- readRDS("~/Dropbox/Projects/kehra/data/datasetAfterCleanup.rds")

```

Assess the present of a linear relationship between temperature and air pollution concentration in terms of PM10. In symbols: $PM_{10} = \beta_0 + \beta_1 * T$

```{r}
# In R
formula <-  PM10 ~ 1 + TEMP
```

Set up the linear model using base R.

```{r}

modelLR <- lm(formula = formula, data = df)
summary(modelLR)

plot(modelLR)

```

Set up the linear model using INLA.

```{r}

# Same using INLA
library(INLA)

modelLRinla <- inla(formula = formula, family = "gaussian", data = df)
summary(modelLRinla)

round(modelLRinla$summary.fixed[,1:5],3)

plot(modelLRinla$summary.fixed[1,1], main="Confidence interval for beta0",
     xlab="", col="brown", pch=20,
     ylim=c(modelLRinla$summary.fixed[1,3],modelLRinla$summary.fixed[1,5]))
points(modelLRinla$summary.fixed[1,3], col="red")
points(modelLRinla$summary.fixed[1,5], col="red")
legend("topright", pch = c(1,20,1,20), 
       legend = c("CI non-inf. prior", "non-inf. prior"),
       col=c("red","brown"))

plot(modelLRinla$summary.fixed[2,1], main="Confidence interval for beta1",
     xlab="", col="brown", pch=20,
     ylim=c(modelLRinla$summary.fixed[2,3],modelLRinla$summary.fixed[2,5]))
points(modelLRinla$summary.fixed[2,3], col="red")
points(modelLRinla$summary.fixed[2,5], col="red")
legend("topright", pch = c(1,20,1,20), 
       legend = c("CI non-inf. prior", "non-inf. prior"),
       col=c("red","brown"))

```

This shows the two approaches (base R and INLA) are interchangable. We will proceed with INLA so that we can incorporate a prior knowledge and assess it's influence on the final results. Base R and INLA return the same results because we assumed a non-informative prior (the parameters of the linear regression come from a uniform distribution).

Let's now assume a __vague prior__ rather than a non-informative one. The regression parameters belong to the following Normal distributions:

$\beta_0 ~ N(0,10000) and \beta_1 ~ N(0,1)$

The mean of each parameter is given by the first term in parenthesys (0 for both). The precision, instead, is 1 over the second term in parenthesys or the inverse of the variance (1 for $\beta_0$ and 1/10000 = 0.0001 for $\beta_1$).

Note that "_the normal distribution is the sub form of Gaussian distribution. Gaussian distribution have 2 parameters, mean and variance. When there is zero mean and unit variance the Gaussian distribution becomes normal other wise it is pronounced as Gaussian_".

```{r}

MeanPrecision <- list(mean=0, prec=1,                           # beta0
                      mean.intercept=0, prec.intercept=0.0001)  # beta1

modelLRinlaVP <- inla(formula = formula, family = "gaussian", data = df, 
                      control.fixed = MeanPrecision)
summary(modelLRinlaVP)

plot(modelLRinla$summary.fixed[1,1], main="Confidence interval for beta0",
     xlab="", col="brown", pch=20,
     ylim=c(min(modelLRinla$summary.fixed[1,3],
                modelLRinlaVP$summary.fixed[1,3]),
            max(modelLRinla$summary.fixed[1,5],
                modelLRinlaVP$summary.fixed[1,5])))
points(modelLRinla$summary.fixed[1,3], col="red")
points(modelLRinla$summary.fixed[1,5], col="red")
points(modelLRinlaVP$summary.fixed[1,1], col="blue", pch=20)
points(modelLRinlaVP$summary.fixed[1,3], col="green")
points(modelLRinlaVP$summary.fixed[1,5], col="green")
legend("topright", pch = c(1,20,1,20), 
       legend = c("CI non-inf. prior", "non-inf. prior",
                  "CI vague prior", "vague prior"),
       col=c("red","brown","green","blue"))

plot(modelLRinla$summary.fixed[2,1], main="Confidence interval for beta1",
     xlab="", col="brown", pch=20,
     ylim=c(min(modelLRinla$summary.fixed[2,3],
                modelLRinlaVP$summary.fixed[2,3]),
            max(modelLRinla$summary.fixed[2,5],
                modelLRinlaVP$summary.fixed[2,5])))
points(modelLRinla$summary.fixed[2,3], col="red")
points(modelLRinla$summary.fixed[2,5], col="red")
points(modelLRinlaVP$summary.fixed[2,1], col="blue", pch=20)
points(modelLRinlaVP$summary.fixed[2,3], col="green")
points(modelLRinlaVP$summary.fixed[2,5], col="green")
legend("topright", pch = c(1,20,1,20), 
       legend = c("CI non-inf. prior", "non-inf. prior",
                  "CI vague prior", "vague prior"),
       col=c("red","brown","green","blue"))

```

If we use __dataset A__, there are some differences emerging from the use of non-informative prior versus a vague prior. The results for a vague prior, for instance) suggest that, independently from the temperature we expect about 84 ug/m3 of particular matter and, 1 Kelvin increase in PM10 causes a small reduction in PM10 (-0.18 with 95% CI in the range [-0.2716, -0.0895] Kelvin).

If we use __dataset B__, there is absolutely no difference using a non-informative prior versus a vague prior. suggests that, independently from the temperature we expect about 4 ug/m3 of particular matter and, 1 unit increase in log(PM10) causes a small reduction in PM10 (-0.0026 with 95% CI in the range [-0.0043, -0.0008]).

In both cases the results are counter-intuitive as we expect PM10 to increase, not decrease with temperature! The reason may be linked to seasonal changes (monthly oscillations perhaps). 

```{r}
# Let's use the non-informative prior, but calculate mean and precision
model.linear <- inla(formula, family="gaussian", data=df,
                     control.predictor=list(compute=TRUE))

res.lin <- (df$PM10 - model.linear$summary.fitted.values$mean) / model.linear$summary.fitted.values$sd
round(model.linear$summary.fitted.values[1:5,1:5],3)

# Plot standardised residuals
plot(res.lin,ylim=c(-150,300),main="",xlab="Days",
     ylab=expression((y[i] - hat(mu[i]))/hat(sigma[i])),xaxt="n")
```

Now, we include month effect.

```{r}
# Include month effect in the model
month <- factor(substring(as.character(df$Date), first=6, last=7))
levels(month) <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
df$month <- month
formula.inla2 <- PM10 ~ 1 + TEMP + month
model.linear2 <- inla(formula.inla2, family="gaussian", data=df,
                      control.predictor = list(compute = TRUE))

round(model.linear2$summary.fixed[,1:5],3)
  res.lin2 <- (df$PM10 - model.linear2$summary.fitted.values$mean) / model.linear2$summary.fitted.values$sd

# *** Code for Figure 5.3 centre
plot(res.lin2,ylim=c(-50,150),main="",xlab="Days",
     ylab=expression((y[i] - hat(mu[i]))/hat(sigma[i])),xaxt="n")
# ***

# Inlcude RW in the model
df$id0 <- seq(1:dim(df)[1])
formula.inla3 <- PM10 ~  1 +  TEMP + month +
                 f(id0, 
                   model="rw1", 
                   hyper = list(prec = list(prior="loggamma",
                                            param=c(1,0.01))))
model.linear3 <- inla(formula.inla3, family="gaussian", data=df,
                      control.predictor = list(compute = TRUE))

round(model.linear3$summary.fixed[,1:5],3)
res.lin3 <- (df$PM10 - model.linear3$summary.fitted.values$mean) / model.linear3$summary.fitted.values$sd

# *** Code for Figure 5.3 bottom
plot(res.lin3,ylim=c(-25,25),main="",xlab="Days",
     ylab=expression((y[i] - hat(mu[i]))/hat(sigma[i])),xaxt="n")
# ***

# *** Code for Figure 5.4
plot(model.linear3$summary.random$id$mean,xaxt="n",
     xlab="Days",ylab=expression(PM[10]),pch=10,cex=0.4,ylim=c(min(model.linear3$summary.random$id$"0.025quant"),max(model.linear3$summary.random$id$"0.975quant")))
```

The above random walk was just an example but, in the final analysis we need to take into account that data comes from different locations and days are repeated (therefore the id changes).

# Spatio-temporal model

Let's jump to the spatio-temporal model.

```{r}
# Load the A. original dataset
temp <- readRDS("~/Dropbox/Projects/kehra/data/Pollution/allPollutantsClima.rds")
df <- temp[,c("id","Date", "Z", "Longitude", "Latitude", "WS", "TEMP", "PM10")]
names(df) <- c("ID", "Date", "A", "Longitude", "Latitude", "WS", "TEMP", "PM10")

# Load the vector containing the spatial info
coords <- readRDS("~/Dropbox/Projects/kehra/data/Pollution/DEFRAcatalogue.rds")
coordinates <- coords[coords$UK.AIR.ID %in% unique(df$id),c("UK.AIR.ID","Longitude","Latitude")]
rownames(coordinates) <- seq(1,dim(coordinates)[1])
library(raster)
UK <- getData("GADM",country="GBR",level=1)
library(ggplot2)
borders <- fortify( UK )

n_stations <- length(coordinates$UK.AIR.ID) # 47 stations
n_data <- length(df$ID)                     # 13601 space-time data
n_days <- n_data/n_stations                 # 365 time points

df$time <- rep(1:n_days, each=n_stations)
coordinates.allyear <- as.matrix(coordinates[df$ID, c("Longitude","Latitude")])
dim(coordinates.allyear)                    # 37960     2

df$logPM10 <- log(df$PM10)
mean_covariates <- apply(df[,3:7],2,mean)
sd_covariates <- apply(df[,3:7],2,sd)
df[,3:7] <- scale(df[,3:7],center=mean_covariates, scale=sd_covariates)


```

